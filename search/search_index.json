{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 This project is an unofficial client for various \"public\" HTTP endpoints that are exposed by draftkings.com . These endpoints are not documented anywhere (to the best of my knowledge), but do not require any sort of authentication. I am in no way affiliated with draftkings.com , and cannot make any guarantees about the underlying HTTP endpoints. Additionally, I cannot make any guarantees about breaking changes associated with the DraftKings API / endpoints as they are free to version and change their data as they see fit (again, to the best of my knowledge, there is no official API). Installation \u00b6 This project is published to PyPi . It can be installed via pip like so pip install draft-kings Note This library requires Python 3.7+ Note This library has two major versions - 2.x (which is being deprecated ), and 3.x (which is being actively developed) Contributions \u00b6 This is an open-source project that welcomes all pull requests and issues - I would love to hear your thoughts and ideas around making this project even better.","title":"Home"},{"location":"#home","text":"This project is an unofficial client for various \"public\" HTTP endpoints that are exposed by draftkings.com . These endpoints are not documented anywhere (to the best of my knowledge), but do not require any sort of authentication. I am in no way affiliated with draftkings.com , and cannot make any guarantees about the underlying HTTP endpoints. Additionally, I cannot make any guarantees about breaking changes associated with the DraftKings API / endpoints as they are free to version and change their data as they see fit (again, to the best of my knowledge, there is no official API).","title":"Home"},{"location":"#installation","text":"This project is published to PyPi . It can be installed via pip like so pip install draft-kings Note This library requires Python 3.7+ Note This library has two major versions - 2.x (which is being deprecated ), and 3.x (which is being actively developed)","title":"Installation"},{"location":"#contributions","text":"This is an open-source project that welcomes all pull requests and issues - I would love to hear your thoughts and ideas around making this project even better.","title":"Contributions"},{"location":"api/","text":"API \u00b6 Client \u00b6 There is a Client class to instantiate that has methods to access the various supported DraftKings endpoints. It can be import ed directly from the draft_kings module. from draft_kings import Client Enums \u00b6 Various enum values are returned as part of the result set for API methods or as inputs for various API methods. They are import ed from the data path. Sport from draft_kings.data import Sport Note Represents the various sports that DraftKings has contests for, like the NFL, MLB, and NBA Output \u00b6 Data is returned as custom objects (and more specifically, instances of custom Class es that utilize the dataclasses module - which is why this project relies on Python 3.7+ ). The returned objects are (effectively) immutable via dataclasses 's frozen property . While immutability is just one reason behind using custom Class es, another benefit is making it easier to use this API with the type-hinting features introduced in Python 3 . Using Class es with defined types makes it (hopefully) much easier to discern what the (theoretically) expected type of any given field should be without having to print out some object. The output objects are located in the draft_kings.output.objects module. There are sub-modules that correspond to each DraftKings endpoint. Why is (pretty much) every field None -able / Optional ? \u00b6 This is a pretty explicit design decision I made when modeling the output data objects. Because I don't have any control of the shape of the data returned by the DraftKings endpoints, if DraftKings decides tomorrow to remove a field, I figured it would be better to return the field with a None value vs. raising some type of parsing / deserialization error. So most of the fields will have the potential of a None value - however, there are some fields that are guaranteed to always have a non- None value. Please check the appropriate Class es defined in the draft_kings.output.objects module if you would like to see the defined return types. Methods \u00b6 Contests For A Given Sport \u00b6 from draft_kings import Sport , Client Client () . contests ( sport = Sport . NBA ) Available Players For A Given Draft Group \u00b6 from draft_kings import Client Client () . available_players ( draft_group_id = 41793 ) Details For A Given Draft Group \u00b6 from draft_kings import Client Client () . draft_group_details ( draft_group_id = 41793 ) Countries \u00b6 from draft_kings import Client Client () . countries () Regions For A Given Country \u00b6 from draft_kings import Client Client () . regions ( country_code = \"US\" ) Get Draftable Player / Match Up Informatiion For A Given Draft Group \u00b6 from draft_kings import Client Client () . draftables ( draft_group_id = 41793 ) Get Rules For A Game Type \u00b6 from draft_kings import Client Client () . game_type_rules ( game_type_id = 1 ) Usage \u00b6 To the best of my knowledge, I have not identified an endpoint that delivers data for a window of time. So generally the usage pattern is something like Use the contests method to get the set of contests for all the Sport s you need data for These Contests will have Draft Group s associated with them - for each of these Draft Group s, use the related APIs to get the information you desire Depending on how frequently you need to display new information, you may need to repeat this set of operations as there does not seem to be a an endpoint to subscribe to new Contest s or Draft Group s (or any type of data update, in general)","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#client","text":"There is a Client class to instantiate that has methods to access the various supported DraftKings endpoints. It can be import ed directly from the draft_kings module. from draft_kings import Client","title":"Client"},{"location":"api/#enums","text":"Various enum values are returned as part of the result set for API methods or as inputs for various API methods. They are import ed from the data path. Sport from draft_kings.data import Sport Note Represents the various sports that DraftKings has contests for, like the NFL, MLB, and NBA","title":"Enums"},{"location":"api/#output","text":"Data is returned as custom objects (and more specifically, instances of custom Class es that utilize the dataclasses module - which is why this project relies on Python 3.7+ ). The returned objects are (effectively) immutable via dataclasses 's frozen property . While immutability is just one reason behind using custom Class es, another benefit is making it easier to use this API with the type-hinting features introduced in Python 3 . Using Class es with defined types makes it (hopefully) much easier to discern what the (theoretically) expected type of any given field should be without having to print out some object. The output objects are located in the draft_kings.output.objects module. There are sub-modules that correspond to each DraftKings endpoint.","title":"Output"},{"location":"api/#why-is-pretty-much-every-field-none-able-optional","text":"This is a pretty explicit design decision I made when modeling the output data objects. Because I don't have any control of the shape of the data returned by the DraftKings endpoints, if DraftKings decides tomorrow to remove a field, I figured it would be better to return the field with a None value vs. raising some type of parsing / deserialization error. So most of the fields will have the potential of a None value - however, there are some fields that are guaranteed to always have a non- None value. Please check the appropriate Class es defined in the draft_kings.output.objects module if you would like to see the defined return types.","title":"Why is (pretty much) every field None-able / Optional ?"},{"location":"api/#methods","text":"","title":"Methods"},{"location":"api/#contests-for-a-given-sport","text":"from draft_kings import Sport , Client Client () . contests ( sport = Sport . NBA )","title":"Contests For A Given Sport"},{"location":"api/#available-players-for-a-given-draft-group","text":"from draft_kings import Client Client () . available_players ( draft_group_id = 41793 )","title":"Available Players For A Given Draft Group"},{"location":"api/#details-for-a-given-draft-group","text":"from draft_kings import Client Client () . draft_group_details ( draft_group_id = 41793 )","title":"Details For A Given Draft Group"},{"location":"api/#countries","text":"from draft_kings import Client Client () . countries ()","title":"Countries"},{"location":"api/#regions-for-a-given-country","text":"from draft_kings import Client Client () . regions ( country_code = \"US\" )","title":"Regions For A Given Country"},{"location":"api/#get-draftable-player-match-up-informatiion-for-a-given-draft-group","text":"from draft_kings import Client Client () . draftables ( draft_group_id = 41793 )","title":"Get Draftable Player / Match Up Informatiion For A Given Draft Group"},{"location":"api/#get-rules-for-a-game-type","text":"from draft_kings import Client Client () . game_type_rules ( game_type_id = 1 )","title":"Get Rules For A Game Type"},{"location":"api/#usage","text":"To the best of my knowledge, I have not identified an endpoint that delivers data for a window of time. So generally the usage pattern is something like Use the contests method to get the set of contests for all the Sport s you need data for These Contests will have Draft Group s associated with them - for each of these Draft Group s, use the related APIs to get the information you desire Depending on how frequently you need to display new information, you may need to repeat this set of operations as there does not seem to be a an endpoint to subscribe to new Contest s or Draft Group s (or any type of data update, in general)","title":"Usage"},{"location":"development/","text":"Development \u00b6 Branches \u00b6 There are two branches, v2 and v3 , which map to the 2.0.0+ and 3.0.0+ versions, respectively. These are the defacto branches to branch from when developing features. The v2 branch (as well as the 2.0.0+ version) will be deprecated in the near-future. master will reflect the latest major version branch. Local \u00b6 Install dependencies using poetry - for installation directions, see the documentation . Once poetry has been installed, dependencies can be installed using the install command like poetry install Note The pyproject.toml file is used to describe the project's requirements and relevant metadata including both the project's dependencies and it's development dependencies (like for generating code coverage, and this documentation site) Testing \u00b6 Unit tests are organized in the unit directory under the tests directory while integration tests are organized under the integration directory. In the cases where tests are extensive (like integration tests for an API method), each of these tests are grouped in a separate file, even if they are implemented in the same file. This is why API methods have their own integration test file under the client directory even though they are all implemented in the client.py file. Currently, this project uses Codecov for code coverage statistics. Continuous Integration \u00b6 GitHub Actions is used for continuous integration to run tests on a variety of operating systems. Documentation Application \u00b6 This project uses the MkDocs library to generate the assets associated with the documentation application. To run the documentation application locally, ensure dependencies are installed and then execute mkdocs serve","title":"Development"},{"location":"development/#development","text":"","title":"Development"},{"location":"development/#branches","text":"There are two branches, v2 and v3 , which map to the 2.0.0+ and 3.0.0+ versions, respectively. These are the defacto branches to branch from when developing features. The v2 branch (as well as the 2.0.0+ version) will be deprecated in the near-future. master will reflect the latest major version branch.","title":"Branches"},{"location":"development/#local","text":"Install dependencies using poetry - for installation directions, see the documentation . Once poetry has been installed, dependencies can be installed using the install command like poetry install Note The pyproject.toml file is used to describe the project's requirements and relevant metadata including both the project's dependencies and it's development dependencies (like for generating code coverage, and this documentation site)","title":"Local"},{"location":"development/#testing","text":"Unit tests are organized in the unit directory under the tests directory while integration tests are organized under the integration directory. In the cases where tests are extensive (like integration tests for an API method), each of these tests are grouped in a separate file, even if they are implemented in the same file. This is why API methods have their own integration test file under the client directory even though they are all implemented in the client.py file. Currently, this project uses Codecov for code coverage statistics.","title":"Testing"},{"location":"development/#continuous-integration","text":"GitHub Actions is used for continuous integration to run tests on a variety of operating systems.","title":"Continuous Integration"},{"location":"development/#documentation-application","text":"This project uses the MkDocs library to generate the assets associated with the documentation application. To run the documentation application locally, ensure dependencies are installed and then execute mkdocs serve","title":"Documentation Application"}]}